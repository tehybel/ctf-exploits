import socket, struct, time, telnetlib, re, sys, os

# pwnlib.py by immerse

# a library I use for writing every CTF challenge exploit.

# I'm aware that most of this code is non-ideal; consider it
# ctf-quality code that has at least been thoroughly tested.


class Socket:
	def __init__(self, server, sock=None):
		if sock is None:
			self.socket = socket.create_connection(server)
		else:
			self.socket = sock
		self.delimiter = None
		self.f = self.socket.makefile("rw", bufsize=0)
	def recv_until(self, string=None):
		if string is None:
			string = self.delimiter
		buf = ""
		while not buf.endswith(string):
			r = self.f.read(1)
			buf += r
			if len(r) == 0:
				raise socket.error(buf)
		return buf[:-len(string)]
	def ru(self, string=None):
		return self.recv_until(string)
	def send(self, string):
		return self.f.write(str(string))
	def recv(self, amount=1024):
		return self.socket.recv(amount)
	def interact(self):
		t = telnetlib.Telnet()
		t.sock = self.socket
		t.interact()
	def close(self):
		return self.socket.close()
	def get_sock(self):
		return self.socket
	def delim(self, d):
		self.delimiter = d
	

def accept(port):
	print "Waiting for connection.."
	serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	serversocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
	serversocket.bind((socket.gethostname(), port))
	serversocket.listen(1)
	s, info = serversocket.accept()
	s = Socket((), sock=s)
	print "Got connection from", info
	return s


pd = lambda x: struct.pack("<I", x)
ud = lambda x: struct.unpack("<I", x)[0]
pq = lambda x: struct.pack("<Q", x)
uq = lambda x: struct.unpack("<Q", x)[0]
ph = lambda x: struct.pack("<H", x)
uh = lambda x: struct.unpack("<H", x)[0]
qd = lambda x: struct.pack(">I", x)
qq = lambda x: struct.pack(">Q", x)
qh = lambda x: struct.pack(">H", x)

def hexlify(string):
	return "".join(["\\x" + char.encode("hex") for char in string])

def match(pattern, string, flags=re.I):
	so = re.search(pattern, string, flags)
	assert so and len(so.groups()) == 1
	return so.group(1)

def blocks(t, l):
	return [t[i:i+l].ljust(l, chr(0)) for i in range(0, len(t), l)]

def strip(string, letters):
	for l in letters:
		string = string.replace(l, "")
	return string

# input:	assembly
# output:	assembled opcodes
def assemble(asm, arch="x86-64"):
	from os import system
	nasm_code = """
	global _start
	section .text
	_start:
	"""
	nasm_code += asm
	open("temp_nasm_code.asm","wb").write(nasm_code)
	NASM_CMD = "/usr/bin/nasm"
	if arch == "x86-64":
		res = system(NASM_CMD + " -f elf64 temp_nasm_code.asm; ld temp_nasm_code.o")
	else:
		res = system(NASM_CMD + " -f elf32 temp_nasm_code.asm; ld -melf_i386 temp_nasm_code.o")
	assert res == 0
	res = system("objcopy -O binary temp_nasm_code.o temp_script_file.txt")
	assert res == 0
	final_sc = open("temp_script_file.txt","r").read()
	system("rm temp_script_file.txt; rm temp_nasm_code.asm; rm temp_nasm_code.o; rm a.out")
	return final_sc

# backwards compatibility
def asm2sc(asm, arch="x86-64"):
	return assemble(asm, arch)

def extract(string, begin_pattern, end_pattern):
	begin = string.find(begin_pattern) + len(begin_pattern)
	end = string.find(end_pattern, begin + 1)
	assert begin >= 0 and end >= 0
	return string[begin:end]

de_bruijn_charset = (
"abcdefghijklmnopqrstuvwxyz" + 
"ABCDEFGHIJKLMNOPQRSTUVWXYZ" + 
"0123456789" +
"#&/()=?^*_-@{}[]+<>"
)

# taken from PEDA
def de_bruijn(charset, n, maxlen):
	k = len(charset)
	a = [0] * k * n
	sequence = []
	def db(t, p):
		if len(sequence) == maxlen:
			return

		if t > n:
			if n % p == 0:
				for j in range(1, p + 1):
					sequence.append(charset[a[j]])
					if len(sequence) == maxlen:
						return
		else:
			a[t] = a[t - p]
			db(t + 1, p)
			for j in range(a[t - p] + 1, k):
				a[t] = j
				db(t + 1, t)
	db(1,1)
	return ''.join(sequence)


def pattern(length):
	return de_bruijn(de_bruijn_charset, 3, length)

def wait(t):
	for i in range(t):
		sys.stdout.write(".")
		sys.stdout.flush()
		time.sleep(1)
	print ""

def _fixed_xor(lhs, rhs):
	assert len(lhs) == len(rhs)
	out = ""
	i = 0
	while i < len(lhs):
		out += chr(ord(lhs[i]) ^ ord(rhs[i]))
		i += 1
	return out

def xor(string, key):
	real_key = key
	while len(real_key) < len(string):
		real_key += key
	real_key = real_key[:len(string)]
	assert len(real_key) == len(string)
	return _fixed_xor(string, real_key)

